using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace F1Game.UDP.SourceGenerator;

[Generator]
sealed class AutoInlineArrayGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(AutoInlineArrayAttributeSource.AddAttributeSource);

		IncrementalValuesProvider<BuildTarget> buildTargets = context.SyntaxProvider.ForAttributeWithMetadataName(
				AutoInlineArrayAttributeSource.FullyQualifiedAutoInlineArrayAttribute,
				predicate: static (node, _) => NodePredicate(node),
				transform: static (ctx, ct) => GetSemanticTargetForGeneration(ctx, ct))
			.Where(static m => m is not null)!;

		context.RegisterSourceOutput(buildTargets, static (context, source) => ExecuteGeneration(context, source));
	}

	static bool NodePredicate(SyntaxNode node)
	{
		return node is TypeDeclarationSyntax { Keyword.RawKind: (int)SyntaxKind.StructKeyword }
			|| node is RecordDeclarationSyntax { ClassOrStructKeyword.RawKind: (int)SyntaxKind.StructKeyword };
	}

	static BuildTarget? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken _)
	{
		if (context.TargetSymbol is not INamedTypeSymbol type)
			return null;

		if (!type.DeclaringSyntaxReferences.Select(x => x.GetSyntax()).Any(x => x is TypeDeclarationSyntax typeSyntax && typeSyntax.Modifiers.Any(SyntaxKind.PartialKeyword)))
			return Diagnostic.Create(DiagnosticDescriptors.TypeMustBePartial, type.Locations[0], type.Name);

		if (context.Attributes.Length > 1)
			return Diagnostic.Create(DiagnosticDescriptors.NoMoreThanOneAttribute, type.Locations[0], type.Name);

		if (context.Attributes[0] is not { } attributeData)
			return null;

		if (attributeData.ConstructorArguments[0].Value is not int length || length <= 0)
			return Diagnostic.Create(DiagnosticDescriptors.LengthShouldBePositiveNumber, type.Locations[0], type.Name);

		var elementTypeFromAttribute = attributeData.ConstructorArguments.Length > 1
			? attributeData.ConstructorArguments[1].Value as ITypeSymbol
			: null;

		var instanceFields = type.GetMembers()
			.OfType<IFieldSymbol>()
			.Where(f => !f.IsStatic && !f.IsConst)
			.ToArray();

		if (instanceFields.Length > 1)
			return Diagnostic.Create(DiagnosticDescriptors.TooManyInstanceFields, type.Locations[0], type.Name);

		return (instanceFields.FirstOrDefault(), elementTypeFromAttribute) switch
		{
			(null, null) when type.IsGenericType && type.TypeParameters.Length > 0 => new GenerationData(type, length, type.TypeParameters[0], true),
			(null, { } elementType) => new GenerationData(type, length, elementType, true),
			({ } field, null) => new GenerationData(type, length, field.Type, false),
			({ }, { }) => Diagnostic.Create(DiagnosticDescriptors.InstanceFieldAndElementTypeArePresent, type.Locations[0], type.Name),
			_ => Diagnostic.Create(DiagnosticDescriptors.NoTypeForInstanceField, type.Locations[0], type.Name),
		};
	}

	static void ExecuteGeneration(SourceProductionContext context, BuildTarget target)
	{
		context.CancellationToken.ThrowIfCancellationRequested();

		if (target.Diagnostic is not null)
		{
			context.ReportDiagnostic(target.Diagnostic);
			return;
		}

		if (target.GenerationData is not GenerationData generationData)
			return;

		var (typeData, length, elementType, generateField) = generationData;
		var (namespaceName, typeName, typeDeclaration, typeMetadataName) = typeData;
		var namespaceDeclaration = namespaceName is null ? "" : $"namespace {namespaceName};";

		string fieldGenerationCode = generateField
			? $$"""
					[SuppressMessage("Style", "IDE0044:Add readonly modifier", Justification = "Inline array element field must be mutable.")]
					[SuppressMessage("CodeQuality", "IDE0051:Remove unused private members", Justification = "Field is used by the runtime for InlineArray layout and access.")]
					private {{elementType}} _element0;
				"""
			: "";

		string source = $$"""
			// <auto-generated/>
			#nullable enable

			using System;
			using System.Collections.Generic;
			using System.Diagnostics.CodeAnalysis;
			using System.Runtime.CompilerServices;

			{{namespaceDeclaration}}

			/// <summary>
			/// Represents an inline array {{typeName}} with {{length}} elements of type <see cref="{{elementType}}"/>.
			/// Provides basic equality comparison and hashing. Access elements using the indexer (e.g., myArray[0]).
			/// </summary>
			[InlineArray({{length}})]
			partial {{typeDeclaration}} {{typeName}}
				: IEquatable<{{typeName}}>
			{
			{{fieldGenerationCode}}

				/// <summary>Gets the fixed length of the inline array: {{length}}.</summary>
				public int Length => {{length}};

				/// <summary>
				/// Returns a <see cref="Span{T}"/> that represents the elements of this inline array.
				/// </summary>
				/// <returns>
				/// A <see cref="Span{T}"/> of length <c>{{length}}</c> that provides mutable access to the elements of the inline array.
				/// </returns>
				public Span<{{elementType}}> AsSpan()
					=> MemoryMarshal.CreateSpan(ref Unsafe.As<{{typeName}}, {{elementType}}>(ref this), {{length}});

				/// <summary>
				/// Returns a <see cref="ReadOnlySpan{T}"/> that represents the elements of this inline array.
				/// </summary>
				/// <returns>
				/// A <see cref="ReadOnlySpan{T}"/> of length <c>{{length}}</c> that provides read-only access to the elements of the inline array.
				/// </returns>
				public ReadOnlySpan<{{elementType}}> AsReadOnlySpan()
					=> MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<{{typeName}}, {{elementType}}>(ref this), {{length}});

				/// <summary>
				/// Returns an <see cref="IEnumerable{T}"/> that enumerates the elements of this inline array.
				/// </summary>
				/// <returns>
				/// An <see cref="IEnumerable{T}"/> that iterates over the elements of the inline array in order.
				/// </returns>
				public IEnumerable<{{elementType}}> AsEnumerable()
				{
					foreach (var item in this)
						yield return item;
				}

				/// <inheritdoc/>
				public override bool Equals([NotNullWhen(true)] object? obj)
					=> obj is {{typeName}} other && Equals(other);

				/// <summary>Indicates whether the current inline array is equal to another inline array of the same type by comparing their elements sequentially.</summary>
				/// <param name="other">An inline array to compare with this instance.</param>
				/// <returns><c>true</c> if the current array's elements are equal to the <paramref name="other"/> array's elements; otherwise, <c>false</c>.</returns>
				public bool Equals({{typeName}} other)
					=> ((ReadOnlySpan<{{elementType}}>)this).SequenceEqual((ReadOnlySpan<{{elementType}}>)other);

				/// <inheritdoc/>
				public override int GetHashCode()
				{
					HashCode hashCode = default;
					ReadOnlySpan<{{elementType}}> span = this;
					var comparer = EqualityComparer<{{elementType}}>.Default;

					foreach (ref readonly {{elementType}} item in span)
						hashCode.Add(item, comparer);

					return hashCode.ToHashCode();
				}

				/// <summary>
				/// Creates a new <see cref="{{typeName}}"/> instance and populates it with elements from the specified <see cref="ReadOnlySpan{T}"/> source.
				/// </summary>
				/// <param name="source">
				/// The sequence of elements to copy into the inline array. If the sequence contains fewer elements than the array's length, the remaining elements are left at their default value.
				/// If the sequence contains more elements than the array's length, the extra elements are ignored.
				/// </param>
				/// <returns>
				/// A new <see cref="{{typeName}}"/> instance containing elements from <paramref name="source"/>.
				/// </returns>
				public static {{typeName}} Create(ReadOnlySpan<{{elementType}}> source)
				{
					var array = new {{typeName}}();
					source[..Math.Min(source.Length, {{length}})].CopyTo(array);
					return array;
				}

				/// <summary>Determines whether two specified instances of <see cref="{{typeName}}"/> are equal by comparing their elements sequence.</summary>
				/// <param name="left">The first inline array to compare.</param>
				/// <param name="right">The second inline array to compare.</param>
				/// <returns><c>true</c> if the arrays are equal; otherwise, <c>false</c>.</returns>
				public static bool operator ==({{typeName}} left, {{typeName}} right)
					=> left.Equals(right);

				/// <summary>Determines whether two specified instances of <see cref="{{typeName}}"/> are not equal by comparing their elements sequence.</summary>
				/// <param name="left">The first inline array to compare.</param>
				/// <param name="right">The second inline array to compare.</param>
				/// <returns><c>true</c> if the arrays are not equal; otherwise, <c>false</c>.</returns>
				public static bool operator !=({{typeName}} left, {{typeName}} right)
					=> !(left == right);

				/// <summary>
				/// Implicitly converts an array of <see cref="{{elementType}}"/> to a <see cref="{{typeName}}"/>.
				/// Copies up to <c>{{length}}</c> elements from the source array; extra elements are ignored, and missing elements are default-initialized.
				/// </summary>
				/// <param name="source">
				/// The source array to copy elements from. If <paramref name="source"/> is <c>null</c>, a default-initialized <see cref="{{typeName}}"/> is returned.
				/// </param>
				/// <returns>
				/// A <see cref="{{typeName}}"/> containing elements from <paramref name="source"/>.
				/// </returns>
				public static implicit operator {{typeName}}({{elementType}}[] source)
					=> source is null ? new() : Create(source);

				/// <summary>
				/// Implicitly converts a <see cref="ReadOnlySpan{T}"/> of <see cref="{{elementType}}"/> to a <see cref="{{typeName}}"/>.
				/// Copies up to <c>{{length}}</c> elements from the source span; extra elements are ignored, and missing elements are default-initialized.
				/// </summary>
				/// <param name="source">
				/// The source span to copy elements from.
				/// </param>
				/// <returns>
				/// A <see cref="{{typeName}}"/> containing elements from <paramref name="source"/>.
				/// </returns>
				public static implicit operator {{typeName}}(ReadOnlySpan<{{elementType}}> source)
					=> Create(source);

				/// <summary>
				/// Implicitly converts a <see cref="Span{T}"/> of <see cref="{{elementType}}"/> to a <see cref="{{typeName}}"/>.
				/// Copies up to <c>{{length}}</c> elements from the source span; extra elements are ignored, and missing elements are default-initialized.
				/// </summary>
				/// <param name="source">
				/// The source span to copy elements from.
				/// </param>
				/// <returns>
				/// A <see cref="{{typeName}}"/> containing elements from <paramref name="source"/>.
				/// </returns>
				public static implicit operator {{typeName}}(Span<{{elementType}}> source)
					=> Create(source);
			}
			""";

		context.AddSource($"{typeMetadataName}.Generated.cs", SourceText.From(source, Encoding.UTF8));
	}
}
