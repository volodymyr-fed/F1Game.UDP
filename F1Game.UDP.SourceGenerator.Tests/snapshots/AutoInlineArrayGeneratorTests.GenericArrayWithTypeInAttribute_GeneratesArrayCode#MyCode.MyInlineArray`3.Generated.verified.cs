//HintName: MyCode.MyInlineArray`3.Generated.cs
// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace MyCode;

/// <summary>
/// Represents an inline array MyInlineArray<T, T2, T3> with 69 elements of type <see cref="double"/>.
/// Provides basic equality comparison and hashing. Access elements using the indexer (e.g., myArray[0]).
/// </summary>
[InlineArray(69)]
partial record struct MyInlineArray<T, T2, T3>
	: IEquatable<MyInlineArray<T, T2, T3>>
{
	[SuppressMessage("Style", "IDE0044:Add readonly modifier", Justification = "Inline array element field must be mutable.")]
	[SuppressMessage("CodeQuality", "IDE0051:Remove unused private members", Justification = "Field is used by the runtime for InlineArray layout and access.")]
	private double _element0;

	/// <summary>Gets the fixed length of the inline array: 69.</summary>
	public int Length => 69;

	/// <summary>
	/// Returns a <see cref="Span{T}"/> that represents the elements of this inline array.
	/// </summary>
	/// <returns>
	/// A <see cref="Span{T}"/> of length <c>69</c> that provides mutable access to the elements of the inline array.
	/// </returns>
	public Span<double> AsSpan()
		=> MemoryMarshal.CreateSpan(ref Unsafe.As<MyInlineArray<T, T2, T3>, double>(ref this), 69);

	/// <summary>
	/// Returns a <see cref="ReadOnlySpan{T}"/> that represents the elements of this inline array.
	/// </summary>
	/// <returns>
	/// A <see cref="ReadOnlySpan{T}"/> of length <c>69</c> that provides read-only access to the elements of the inline array.
	/// </returns>
	public ReadOnlySpan<double> AsReadOnlySpan()
		=> MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<MyInlineArray<T, T2, T3>, double>(ref this), 69);

	/// <summary>
	/// Returns an <see cref="IEnumerable{T}"/> that enumerates the elements of this inline array.
	/// </summary>
	/// <returns>
	/// An <see cref="IEnumerable{T}"/> that iterates over the elements of the inline array in order.
	/// </returns>
	public IEnumerable<double> AsEnumerable()
	{
		foreach (var item in this)
			yield return item;
	}

	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj)
		=> obj is MyInlineArray<T, T2, T3> other && Equals(other);

	/// <summary>Indicates whether the current inline array is equal to another inline array of the same type by comparing their elements sequentially.</summary>
	/// <param name="other">An inline array to compare with this instance.</param>
	/// <returns><c>true</c> if the current array's elements are equal to the <paramref name="other"/> array's elements; otherwise, <c>false</c>.</returns>
	public bool Equals(MyInlineArray<T, T2, T3> other)
		=> ((ReadOnlySpan<double>)this).SequenceEqual((ReadOnlySpan<double>)other);

	/// <inheritdoc/>
	public override int GetHashCode()
	{
		HashCode hashCode = default;
		ReadOnlySpan<double> span = this;
		var comparer = EqualityComparer<double>.Default;

		foreach (ref readonly double item in span)
			hashCode.Add(item, comparer);

		return hashCode.ToHashCode();
	}

	/// <summary>
	/// Creates a new <see cref="MyInlineArray<T, T2, T3>"/> instance and populates it with elements from the specified <see cref="ReadOnlySpan{T}"/> source.
	/// </summary>
	/// <param name="source">
	/// The sequence of elements to copy into the inline array. If the sequence contains fewer elements than the array's length, the remaining elements are left at their default value.
	/// If the sequence contains more elements than the array's length, the extra elements are ignored.
	/// </param>
	/// <returns>
	/// A new <see cref="MyInlineArray<T, T2, T3>"/> instance containing elements from <paramref name="source"/>.
	/// </returns>
	public static MyInlineArray<T, T2, T3> Create(ReadOnlySpan<double> source)
	{
		var array = new MyInlineArray<T, T2, T3>();
		source[..Math.Min(source.Length, 69)].CopyTo(array);
		return array;
	}

	/// <summary>Determines whether two specified instances of <see cref="MyInlineArray<T, T2, T3>"/> are equal by comparing their elements sequence.</summary>
	/// <param name="left">The first inline array to compare.</param>
	/// <param name="right">The second inline array to compare.</param>
	/// <returns><c>true</c> if the arrays are equal; otherwise, <c>false</c>.</returns>
	public static bool operator ==(MyInlineArray<T, T2, T3> left, MyInlineArray<T, T2, T3> right)
		=> left.Equals(right);

	/// <summary>Determines whether two specified instances of <see cref="MyInlineArray<T, T2, T3>"/> are not equal by comparing their elements sequence.</summary>
	/// <param name="left">The first inline array to compare.</param>
	/// <param name="right">The second inline array to compare.</param>
	/// <returns><c>true</c> if the arrays are not equal; otherwise, <c>false</c>.</returns>
	public static bool operator !=(MyInlineArray<T, T2, T3> left, MyInlineArray<T, T2, T3> right)
		=> !(left == right);

	/// <summary>
	/// Implicitly converts an array of <see cref="double"/> to a <see cref="MyInlineArray<T, T2, T3>"/>.
	/// Copies up to <c>69</c> elements from the source array; extra elements are ignored, and missing elements are default-initialized.
	/// </summary>
	/// <param name="source">
	/// The source array to copy elements from. If <paramref name="source"/> is <c>null</c>, a default-initialized <see cref="MyInlineArray<T, T2, T3>"/> is returned.
	/// </param>
	/// <returns>
	/// A <see cref="MyInlineArray<T, T2, T3>"/> containing elements from <paramref name="source"/>.
	/// </returns>
	public static implicit operator MyInlineArray<T, T2, T3>(double[] source)
		=> source is null ? new() : Create(source);

	/// <summary>
	/// Implicitly converts a <see cref="ReadOnlySpan{T}"/> of <see cref="double"/> to a <see cref="MyInlineArray<T, T2, T3>"/>.
	/// Copies up to <c>69</c> elements from the source span; extra elements are ignored, and missing elements are default-initialized.
	/// </summary>
	/// <param name="source">
	/// The source span to copy elements from.
	/// </param>
	/// <returns>
	/// A <see cref="MyInlineArray<T, T2, T3>"/> containing elements from <paramref name="source"/>.
	/// </returns>
	public static implicit operator MyInlineArray<T, T2, T3>(ReadOnlySpan<double> source)
		=> Create(source);

	/// <summary>
	/// Implicitly converts a <see cref="Span{T}"/> of <see cref="double"/> to a <see cref="MyInlineArray<T, T2, T3>"/>.
	/// Copies up to <c>69</c> elements from the source span; extra elements are ignored, and missing elements are default-initialized.
	/// </summary>
	/// <param name="source">
	/// The source span to copy elements from.
	/// </param>
	/// <returns>
	/// A <see cref="MyInlineArray<T, T2, T3>"/> containing elements from <paramref name="source"/>.
	/// </returns>
	public static implicit operator MyInlineArray<T, T2, T3>(Span<double> source)
		=> Create(source);
}